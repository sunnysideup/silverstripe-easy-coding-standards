#!/usr/bin/env bash

set -e

if [ -z "$1" ]; then
    echo "Usage: $0 <composer-package OR git-url>"
    exit 1
fi

target="$1"
tmpDir="./_scan_tmp"
mkdir -p "$tmpDir"

# -------------------------------------
# Load GitHub token from composer auth
# -------------------------------------
authFile="$HOME/.config/composer/auth.json"

if [ -f "$authFile" ]; then
    GITHUB_TOKEN=$(jq -r '.["github-oauth"]["github.com"] // empty' "$authFile")
fi

if [ -z "$GITHUB_TOKEN" ] || [ "$GITHUB_TOKEN" = "null" ]; then
    echo "❌ No GitHub token found."
    echo "Make sure you have a token in:"
    echo "  ~/.config/composer/auth.json"
    echo
    echo "Or set it manually:"
    echo "  export GITHUB_TOKEN=xxxx"
    exit 1
fi

echo "✔ Loaded GitHub token from composer auth.json"
echo

# ----------------------------------------------------
# 1. VERSION RULE SETS (edit here)
# ----------------------------------------------------
# A repo is READY if ANY rule in the chosen ruleset matches.

declare -A SS6_RULES=(
    ["silverstripe/framework"]="^6"
    ["silverstripe/admin"]="^6"
    ["silverstripe/versioned"]="^3"
    ["silverstripe/cms"]="^6"
    ["silverstripe/recipe-cms"]="^6"
)
declare -A SS7_RULES=(
    ["silverstripe/framework"]="^7"
)

# Choose which ruleset to apply
ACTIVE_RULESET="SS6_RULES"
eval "ruleset_keys=(\"\${!$ACTIVE_RULESET[@]}\")"

echo "Using ruleset: $ACTIVE_RULESET"
echo

get_rule_value() {
    local key="$1"
    eval "echo \"\${$ACTIVE_RULESET[$key]}\""
}

# ----------------------------------------------------
# 2. Resolve composer package → repo URL
# ----------------------------------------------------
resolve_repo_from_composer() {
    pkg="$1"
    curl -s "https://repo.packagist.org/p2/$pkg.json" \
        | jq -r '.packages[][].source.url' \
        | sed 's|git://|https://|; s|git@github.com:|https://github.com/|' \
        | head -n1
}

if [[ "$target" =~ ^https?:// ]]; then
    repoUrl="$target"
else
    echo "Resolving '$target' via Packagist..."
    repoUrl=$(resolve_repo_from_composer "$target")
fi

if [ -z "$repoUrl" ]; then
    echo "❌ Could not resolve repository."
    exit 1
fi

# Extract GitHub owner/repo
if [[ "$repoUrl" =~ github.com[:/]+([^/]+)/([^/.]+) ]]; then
    owner="${BASH_REMATCH[1]}"
    repo="${BASH_REMATCH[2]}"
else
    echo "❌ Only GitHub repositories supported."
    exit 1
fi

echo "Repository: $owner/$repo"
echo

# ----------------------------------------------------
# 3. Fetch all forks
# ----------------------------------------------------
echo "Fetching forks…"

forksUrl="https://api.github.com/repos/$owner/$repo/forks?per_page=100"

apiResponse=$(curl -s \
    -H "Authorization: token $GITHUB_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    "$forksUrl"
)

if [[ "$apiResponse" == "" ]] || [[ "$apiResponse" =~ "<" ]]; then
    echo "❌ GitHub returned non-JSON output:"
    echo "$apiResponse"
    exit 1
fi

jsonType=$(echo "$apiResponse" | jq -r 'type')

if [ "$jsonType" = "object" ]; then
    message=$(echo "$apiResponse" | jq -r '.message // empty')
    if [ -n "$message" ] && [ "$message" != "null" ]; then
        echo "❌ GitHub API error: $message"
        echo "Full response:"
        echo "$apiResponse"
        exit 1
    fi

    echo "❌ Unexpected JSON object instead of array:"
    echo "$apiResponse"
    exit 1
fi

if [ "$jsonType" != "array" ]; then
    echo "❌ Unexpected JSON type: $jsonType"
    echo "$apiResponse"
    exit 1
fi

forks=$(echo "$apiResponse" | jq -r '.[].full_name')

# Build list of all repos (original + forks)
allRepos=("$owner/$repo")

if [ -n "$forks" ]; then
    while read -r f; do
        allRepos+=("$f")
    done <<< "$forks"
fi

# ----------------------------------------------------
# 4. Branch + composer checks
# ----------------------------------------------------
check_branch() {
    local full="$1"
    local branch="$2"
    echo "  Checking branch: $branch"
    # get full tree recursively
    tree=$(curl -s \
        -H "Authorization: token $GITHUB_TOKEN" \
        "https://api.github.com/repos/$full/git/trees/$branch?recursive=1"
    )

    # invalid? skip
    if [[ -z "$tree" ]] || [[ "$tree" =~ "<" ]]; then
        return 1
    fi

    # get all composer.json files (root or nested)
    paths=$(echo "$tree" | jq -r '.tree[] | select(.path | endswith("composer.json")) | .path')

    if [ -z "$paths" ]; then
        return 1
    fi

    # check each composer.json found
    while read -r path; do
        comp=$(curl -s -L \
            -H "Authorization: token $GITHUB_TOKEN" \
            "https://raw.githubusercontent.com/$full/$branch/$path"
        )

        if ! echo "$comp" | jq -e '.' >/dev/null 2>&1; then
            continue
        fi

        for pkg in "${ruleset_keys[@]}"; do
            need=$(get_rule_value "$pkg")
            have=$(echo "$comp" | jq -r ".require[\"$pkg\"] // empty")

            major=${need#"^"}   # strips the leading ^

            if [[ -n "$have" && ( "$have" == "$need"* || "$have" == "$major"* ) ]]; then
                echo "  ✔ MATCH in branch '$branch' ($path): $pkg ($have) — requires $need"
                echo "$full ($branch)" >> "$tmpDir/ready.txt"
                return 0
            else
                echo "    No match for $pkg: have '$have', need '$need' or '$major'*"
            fi
        done
    done <<< "$paths"

    return 1
}


check_repo() {
    full="$1"
    echo "Checking $full"

    branches=$(curl -s \
        -H "Authorization: token $GITHUB_TOKEN" \
        "https://api.github.com/repos/$full/branches?per_page=100" \
        | jq -r '.[].name'
    )

    if [ -z "$branches" ]; then
        echo "  ❌ could not fetch branches"
        echo
        return
    fi

    for branch in $branches; do
        check_branch "$full" "$branch" && {
            echo "  ✔ READY (via branch: $branch)"
            echo
            return
        }
    done

    echo "  ✗ no SS6-ready branch found"
    echo
}

# ----------------------------------------------------
# 5. Process all repos
# ----------------------------------------------------
rm -f "$tmpDir/ready.txt"

for r in "${allRepos[@]}"; do
    check_repo "$r"
done

echo "----------------------------------------"
echo "READY repos for ruleset $ACTIVE_RULESET:"
if [ -f "$tmpDir/ready.txt" ]; then
    cat "$tmpDir/ready.txt"
else
    echo "(none)"
fi
echo "----------------------------------------"
